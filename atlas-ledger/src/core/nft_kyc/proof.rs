use sha2::{Sha256, Digest};
use crate::core::nft_kyc::model::KycNft;

/// Computes a symbolic SHA-256 hash of a [`KycNft`] for proof-of-integrity purposes.
///
/// This hash is deterministic and includes:
/// - subject
/// - issuer
/// - verification level (as byte)
/// - issued timestamp (as little-endian bytes)
/// - revoked status (`0` or `1`)
/// - optional metadata
/// - optional external_url
///
/// # Returns
/// A 32-byte array representing the NFT's proof hash.
///
/// # Example
/// ```rust
/// use nimble_protocol::core::{
///     nft_kyc::{model::{KycNft, KycLevel}, 
///     proof::{calculate_proof_hash, hash_as_hex}}};
/// 
/// let nft = KycNft::new(
///     "user1",
///     "issuer_xyz",
///     KycLevel::Advanced,
///     1680000,
///     Some("doc_hash_xyz".into()),
///     Some("https://issuer.xyz/user1".into()),
/// );
/// 
/// let hash = calculate_proof_hash(&nft);
/// let hex = hash_as_hex(&hash);
/// println!("Proof: {}", hex);
/// ```

pub fn calculate_proof_hash(nft: &KycNft) -> [u8; 32] {
    let mut hasher = Sha256::new();

    hasher.update(nft.subject.as_bytes());
    hasher.update(nft.issuer.as_bytes());
    hasher.update(&(nft.level as u8).to_le_bytes());
    hasher.update(&nft.issued_at.to_le_bytes());

    let revoked_byte = if nft.revoked { 1u8 } else { 0u8 };
    hasher.update(&[revoked_byte]);

    if let Some(meta) = &nft.metadata {
        hasher.update(meta.as_bytes());
    }

    if let Some(url) = &nft.external_url {
        hasher.update(url.as_bytes());
    }

    let result = hasher.finalize();
    let mut out = [0u8; 32];
    out.copy_from_slice(&result[..32]);
    out
}

/// Converts a 32-byte SHA-256 hash into a lowercase hexadecimal string.
///
/// This is useful for displaying, storing, or transmitting the proof hash
/// generated by [`calculate_proof_hash`] in a human-readable and API-friendly format.
///
/// The result is a 64-character lowercase hex string (each byte = 2 hex chars).
///
/// # Arguments
///
/// * `hash` - A reference to a `[u8; 32]` hash array, typically produced by `calculate_proof_hash`.
///
/// # Returns
///
/// A `String` containing the hexadecimal representation of the input hash.
///
/// # Example
///
/// ```rust
/// use nimble_protocol::core::{
///     nft_kyc::{model::{KycNft, KycLevel}, 
///     proof::{calculate_proof_hash, hash_as_hex}}};
///
/// let nft = KycNft::new(
///     "user1",
///     "issuer_xyz",
///     KycLevel::Advanced,
///     1680000,
///     Some("doc_hash_xyz".into()),
///     Some("https://issuer.xyz/user1".into()),
/// );
///
/// let hash = calculate_proof_hash(&nft);
/// let hex = hash_as_hex(&hash);
///
/// assert_eq!(hex.len(), 64); // 32 bytes = 64 hex chars
/// println!("Hex proof: {}", hex);
/// ```
pub fn hash_as_hex(hash: &[u8; 32]) -> String {
    hex::encode(hash)
}

